'***********************************************************************************************************
'			Tibbit #26 (IR command processor)
'***********************************************************************************************************

include "global.tbh"

'--------------------------------------------------------------------
const IR_INIT_SIGNATURE=&h4952
const IR_STAMP="IRP> "
const IR_CR_LF=chr(13)+chr(10)
const MAX_IR_CMD_LEN=250

const IR_PROTOCOL_NEC=1 
const IR_PROTOCOL_JVC=2 
const IR_PROTOCOL_HITACHI=3
const IR_PROTOCOL_DAIKIN=4
const IR_PROTOCOL_MITSUBISHI=5


type ir_protocol_struct
	protocol as byte
	protocol_name as string(10)
	header_mark as word
	header_space as word
	logic_1_mark as word
	logic_1_space as word
	logic_0_mark as word
	logic_0_space as word
	trailer_mark as word
	trailer_space as word
end type

dim ir_protocols(6) as ir_protocol_struct

dim bcount as dword=0

'--------------------------------------------------------------------
#if IR_DEBUG_PRINT=1
	declare sub ir_debug_print(data as string)
#endif

declare sub tbt26_start_send(byref carrier as string, length as word, pin_cs as byte, channel as byte)

'--------------------------------------------------------------------
dim spi_num_tbt26 as byte
dim ir_init_flag as word
dim tbt26_carrier as no_yes
dim tbt26_freq_div as word
dim tbt26_multiplier as float=1


'====================================================================
function tbt26_init(byref signature as string, pin_miso as byte, pin_mosi as byte, pin_clk as byte, pin_cs as byte, byref channel as byte) as errcheck
'Call this function to initialize the Tibbit.
'This library requires an SSI channel. If all channels are already occupied then this function will return TBT26_NO_SSI_AVAILABLE.
	dim delay as dword
	dim s as string
	dim x as byte
	
	tbt26_init=TBT26_OK
	#if IR_DEBUG_PRINT=1
		ir_debug_print("++++++++++")
	#endif
	ir_init_flag=IR_INIT_SIGNATURE

	spi_num_tbt26=ssi_get(signature)
	if spi_num_tbt26=255 then
		tbt26_init=TBT26_NO_SSI_AVAILABLE
		exit function
	end if
	channel=spi_num_tbt26
	
	ssi.channel=spi_num_tbt26
	
	'SPI CS
	io.num=pin_cs
	io.state=HIGH
	io.enabled=YES
	
	
	'SPI CLK
	io.num=pin_clk
	io.state=HIGH
	io.enabled=YES							'Enable as output
	
	'SPI DO (MOSI)
	io.num=pin_mosi
	io.state=HIGH
	io.enabled=YES


	'SPI DI (MISO)
	io.num=pin_miso
	io.enabled=NO

	'setup SSI channel
	ssi.channel=spi_num_tbt26
	ssi.mode=PL_SSI_MODE_2
	ssi.clkmap=pin_clk
	ssi.dimap=pin_miso
	ssi.domap=pin_mosi
	ssi.zmode=PL_SSI_ZMODE_ALWAYS_ENABLED
	ssi.direction=PL_SSI_DIRECTION_LEFT
	ssi.baudrate=PL_SSI_BAUD_100kHz
		

	ssi.enabled=NO
	io.lineset(pin_clk,LOW) 	'Pepare to rising edge generation
	io.lineset(pin_clk,HIGH)	'CRESETn is now low
	
	delay=sys.timercountms+1
	while sys.timercountms<delay
		'wait
	wend
	
	io.lineset(pin_cs,LOW)
	
	delay=sys.timercountms+1
	while sys.timercountms<delay
		'wait
	wend
	
	io.lineset(pin_clk,LOW) 	'Pepare to rising edge generation
	io.lineset(pin_clk,HIGH)	'CRESETn is now high and FPGA is going to clear internal configuration memory
	
	delay=sys.timercountms+1
	while sys.timercountms<delay
		'wait
	wend
	
	'Upload the run-time binary into the FPGA
	ssi.enabled=YES
	romfile.open("IR_Remote_bitmap.bin")
	s=romfile.getdata(255)
	x=len(s)
	while x>0
		ssi.str(s,PL_SSI_ACK_OFF)
		s=romfile.getdata(255)
		x=len(s)
	wend
	
	ssi.enabled=NO
	for delay = 0 to 50 		'Send 50 dummy bits
		io.lineset(pin_clk,LOW)
		io.lineset(pin_clk,HIGH)
	next delay
	
	ssi.mode=PL_SSI_MODE_0
	ssi.enabled=YES
	io.lineset(pin_cs,HIGH) 	'Switch MISO to cDONE
	if io.lineget(pin_miso)=LOW then 	 	'If 1 - configuration correct, if 0 - ERROR
		sys.debugprint("FPGA configuration failed\x0A\x0D")
	end if

	#if IR_DEBUG_PRINT=1
		sys.debugprint("FPGA configured\x0A\x0D")
		ir_debug_print("----------")
	#endif
	
	'tbt26_init=TBT26_INIT_FAILURE

	'Unknown protocol
	ir_protocols(0).protocol=0
	ir_protocols(0).protocol_name="Unknown"
	'NEC protocol
	ir_protocols(1).protocol=IR_PROTOCOL_NEC
	ir_protocols(1).header_mark=9000
	ir_protocols(1).header_space=4500
	ir_protocols(1).logic_1_mark=560
	ir_protocols(1).logic_1_space=1688
	ir_protocols(1).logic_0_mark=560
	ir_protocols(1).logic_0_space=562
	ir_protocols(1).trailer_mark=562
	ir_protocols(1).trailer_space=562
	ir_protocols(1).protocol_name="NEC"
	'JVC protocol
	ir_protocols(2).protocol=IR_PROTOCOL_JVC
	ir_protocols(2).header_mark=8400
	ir_protocols(2).header_space=4200
	ir_protocols(2).logic_1_mark=526
	ir_protocols(2).logic_1_space=1574
	ir_protocols(2).logic_0_mark=526
	ir_protocols(2).logic_0_space=524
	ir_protocols(2).trailer_mark=524
	ir_protocols(2).trailer_space=524
	ir_protocols(2).protocol_name="JVC"
	'Hitachi protocol
	ir_protocols(3).protocol=IR_PROTOCOL_HITACHI
	ir_protocols(3).header_mark=3300
	ir_protocols(3).header_space=1700
	ir_protocols(3).logic_1_mark=400
	ir_protocols(3).logic_1_space=1200
	ir_protocols(3).logic_0_mark=400
	ir_protocols(3).logic_0_space=500
	ir_protocols(3).protocol_name="Hitachi"

	'Daikin protocol
	ir_protocols(4).protocol=IR_PROTOCOL_DAIKIN
	ir_protocols(4).header_mark=3600
	ir_protocols(4).header_space=1600
	ir_protocols(4).logic_1_mark=400
	ir_protocols(4).logic_1_space=1300
	ir_protocols(4).logic_0_mark=400
	ir_protocols(4).logic_0_space=428
	ir_protocols(4).protocol_name="Daikin"

	'Mitsubishi protocol
	ir_protocols(5).protocol=IR_PROTOCOL_MITSUBISHI
	ir_protocols(5).header_mark=3400
	ir_protocols(5).header_space=1750
	ir_protocols(5).logic_1_mark=450
	ir_protocols(5).logic_1_space=1300
	ir_protocols(5).logic_0_mark=400
	ir_protocols(5).logic_0_space=428
	ir_protocols(5).protocol_name="Mitsubishi"
end function

sub tbt26_start_recording(inverted as no_yes, carrier as no_yes, freq_div as word, pin_cs as byte, channel as byte) 
'Call this function to start the IR signal recording process, i.e. before pressing a button on a remote control you want to clone.
'Call tbt26_get_data() to read out the recorded data (after you've pressed the button on the remote control you are cloning).<br><br>
'Arguments:<br><br>
'inverted: NO- for receivers that output LOW when the IR light is detected, YES- for receivers that output HIGH when the IR light is detected.<br><br>
'carrier: NO- carrier frequency is not present in the incoming IR stream, YES- carrier frequency is present.<br><br>
'freq_div (used only when carrier=NO): frequency divider for the EXPECTED carrier frequency. The formula is freq_div = 12MHz / carrier_freq.<br><br>
'Returns: IR data. First two bytes are low and high bytes of the divider value for the carrier frequency.
'Subsequent byte pairs are low and high bytes of "IR ON" and "IR OFF" periods of the signal expressed in clocks of the carrier frequency.<br><br>
	
	tbt26_carrier=carrier
	tbt26_freq_div=freq_div

	if ir_init_flag<>IR_INIT_SIGNATURE then
		sys.debugprint("IR tibbit not initialized\r\n")
		exit sub
		' tbt26_init()
	end if

	ssi.channel=channel
	
	if carrier=NO then
		io.lineset(pin_cs,LOW) 
		ssi.value(&h02,8)
		ssi.value(&h00,8)
		ssi.value(&h06,8)
		ssi.value(freq_div and &hFF,8)
		ssi.value(freq_div/256,8)
		io.lineset(pin_cs,HIGH)
	end if

	'Send self-learning enable command
	io.lineset(pin_cs,LOW)
	ssi.value(&h02,8)
	ssi.value(&h00,8)
	ssi.value(&h00,8)
	
	if carrier=YES then
		if inverted=YES then
			ssi.value(&h04,8)
		else
			ssi.value(&h00,8)
		end if
	else
		if inverted=YES then
			ssi.value(&h14,8)
		else
			ssi.value(&h10,8)
		end if
	end if
	
	io.lineset(pin_cs,HIGH)
	
	io.lineset(pin_cs,LOW)
	ssi.value(&h02,8)
	ssi.value(&h00,8)
	ssi.value(&h00,8)
	
	if carrier=YES then
		if inverted=YES then
			ssi.value(&h06,8)
		else
			ssi.value(&h02,8)
		end if	
	else
		if inverted=YES then
			ssi.value(&h16,8)
		else
			ssi.value(&h12,8)
		end if
	end if
	
	io.lineset(pin_cs,HIGH)
end sub

function tbt26_get_duration() as word
	tbt26_get_duration=0
	dim data_low,data_high as byte
	data_low=ssi.value(&h00,8)
	data_high=ssi.value(&h00,8)
	tbt26_get_duration=(data_high SHL 8) + data_low
	tbt26_get_duration=tbt26_get_duration*tbt26_multiplier
	' sys.debugprint("IRWR> READ" + str(tbt26_get_duration) + "\r\n")
end function

function tbt26_get_byte_nec() as byte
	tbt26_get_byte_nec=0
	dim data_low,data_high,f as byte
	dim tmp as word
	dim count as word
	dim ss as string=""
	dim bb as string=""
	'addr_high
	for f=1 to 16
		tmp=tbt26_get_duration()
		bb=bb+str(tmp) + ","
		if f MOD 2 = 0 then
			count=count+tmp
			tbt26_get_byte_nec=tbt26_get_byte_nec SHL 1
			'off pause
			if count>=1500 then
				tbt26_get_byte_nec=tbt26_get_byte_nec+1
				ss=ss+"1"
			else
				ss=ss+"0"
			end if
		else
			count=tmp
		end if		
	next f
	' sys.debugprint(ss+"\r\n")
'	sys.debugprint(bb+"\r\n")
end function

function tbt26_get_data_nec() as string
'Call this function to read out the recorded IR signal. Do this only after the signal has been received
'(after you've pressed the button on the remote control you are cloning).
	
	dim data_low,data_high as byte
	dim data_len as word
	dim f as word
	dim command_length as byte

	tbt26_multiplier=26

	if ir_init_flag<>IR_INIT_SIGNATURE then
		sys.debugprint("IR tibbit not initialized\r\n")
		exit function
		' tbt26_init()
	end if

	ssi.channel=spi_num_tbt26
	
	io.lineset(TBT26_SPI_CS,LOW) 	'Read Status
	ssi.value(&h03,8)
	ssi.value(&h00,8)
	ssi.value(&h01,8)
	ssi.value(&h00,8)
	data_low = ssi.value(&h00,8) 'status in data_low
	io.lineset(TBT26_SPI_CS,HIGH)

	if data_low<>&h0003 then
		sys.debugprint("not nec")
		tbt26_get_data_nec=""
		exit function
	end if	
		
	io.lineset(TBT26_SPI_CS,LOW) 	'Read Length of sequence
	ssi.value(&h03,8)
	ssi.value(&h00,8)
	ssi.value(&h04,8)
	ssi.value(&h00,8)
	data_low = ssi.value(&h00,8)
	data_high = ssi.value(&h00,8)
	io.lineset(TBT26_SPI_CS,HIGH)

	data_len=data_high SHL 8
	data_len=data_len+data_low

	io.lineset(TBT26_SPI_CS,LOW) 	'Read Carrier
	ssi.value(&h03,8)
	ssi.value(&h00,8)
	ssi.value(&h06,8)
	ssi.value(&h00,8)
	data_low = ssi.value(&h00,8)
	data_high = ssi.value(&h00,8)
	io.lineset(TBT26_SPI_CS,HIGH)

	if tbt26_carrier=NO then
		data_low =tbt26_freq_div and &hFF
		data_high=tbt26_freq_div/256
	end if

	tbt26_get_data_nec=chr(data_low)+chr(data_high)

	io.lineset(TBT26_SPI_CS,LOW) 	'Read command sequence
	ssi.value(&h03,8)
	ssi.value(&h08,8)
	ssi.value(&h00,8)
	ssi.value(&h00,8)
	
	dim addr as byte=0
	dim tmp as word=0
	dim command as word=0
	dim command_len as word=0
	'9ms
	tmp=tbt26_get_duration()
	sys.debugprint(str(tmp)+"\r\n")
	
	'4.5ms
	tmp=tbt26_get_duration()
	sys.debugprint(str(tmp)+"\r\n")
	
	addr=tbt26_get_byte_nec()
	tmp=tbt26_get_byte_nec()
	tbt26_get_data_nec=tbt26_get_data_nec+chr(addr)
	tbt26_get_data_nec=tbt26_get_data_nec+chr(tmp)
	
	command_len=data_len-4-4-32-32
	command_len=command_len/32
	
	for f=1 to command_len
		tmp=tbt26_get_byte_nec()
		tbt26_get_data_nec=tbt26_get_data_nec+chr(tmp)
	next f
	
	io.lineset(TBT26_SPI_CS,HIGH)
end function

sub tbt26_write_duration(data as word)
	dim ff as float=data/tbt26_multiplier
	dim gg as word=ff
	dim tmp as word=gg AND &hFF
	ssi.value(tmp,8)
	tmp=gg SHR 8
	ssi.value(tmp,8)
	bcount=bcount+2
	' sys.debugprint("IRWR>" + str(data)+"\r\n")
end sub

sub tbt26_write_byte_nec(data as byte)
	dim f as byte
	dim ss as string=""
	for f=1 to 8
		tbt26_write_duration(560)
		dim b as byte=(data SHR (8-f)) AND &h01
		if b=1 then
			tbt26_write_duration(1688)
			ss=ss+"1"
		else
			tbt26_write_duration(562)
			ss=ss+"0"
		end if
	next f
	' sys.debugprint(ss+"\r\n")
end sub

sub tbt26_transmit(inverted as no_yes, pin_cs as byte, channel as byte)
	ssi.channel=channel
	
	sys.debugprint("sending" + lstr(bcount)+"\r\n")
	
	io.lineset(pin_cs,LOW)	'Transmission start command
	ssi.value(&h02,8)
	ssi.value(&h00,8)
	ssi.value(&h00,8)
	if inverted=NO then
		ssi.value(&h00,8)
	else
		ssi.value(&h08,8)
	end if
	io.lineset(pin_cs,HIGH)
	
	io.lineset(pin_cs,LOW)	
	ssi.value(&h02,8)
	ssi.value(&h00,8)
	ssi.value(&h00,8)
	if inverted=NO then
		ssi.value(&h01,8)
	else
		ssi.value(&h09,8)
	end if
	io.lineset(pin_cs,HIGH)
end sub



function tbt26_get_data(pin_cs as byte, channel as byte) as string
'Call this function to read out the recorded IR signal. Do this only after the signal has been received
'(after you've pressed the button on the remote control you are cloning).
	
	dim data_low,data_high as byte
	dim data_len as word
	dim f as word

	if ir_init_flag<>IR_INIT_SIGNATURE then
		sys.debugprint("IR tibbit not initialized\r\n")
		exit function
		' tbt26_init()
	end if

	ssi.channel=channel
	
	io.lineset(pin_cs,LOW) 	'Read Status
	ssi.value(&h03,8)
	ssi.value(&h00,8)
	ssi.value(&h01,8)
	ssi.value(&h00,8)
	data_low = ssi.value(&h00,8) 'status in data_low
	io.lineset(pin_cs,HIGH)

	if data_low<>&h0003 then
		tbt26_get_data=""
		exit function
	end if
		
	io.lineset(pin_cs,LOW) 	'Read Length of sequence
	ssi.value(&h03,8)
	ssi.value(&h00,8)
	ssi.value(&h04,8)
	ssi.value(&h00,8)
	data_low = ssi.value(&h00,8)
	data_high = ssi.value(&h00,8)
	io.lineset(pin_cs,HIGH)

	'combine data_low and data_high
	data_len=data_high SHL 8
	data_len=data_len+data_low


	tbt26_get_data = tbt26_get_data + chr(data_low)+chr(data_high) 'length

	io.lineset(pin_cs,LOW) 	'Read Carrier
	ssi.value(&h03,8)
	ssi.value(&h00,8)
	ssi.value(&h06,8)
	ssi.value(&h00,8)
	data_low = ssi.value(&h00,8)
	data_high = ssi.value(&h00,8)
	io.lineset(pin_cs,HIGH)
	
	if tbt26_carrier=NO then
		data_low =tbt26_freq_div and &hFF
		data_high=tbt26_freq_div/256
	end if

	'freq_div = 12MHz / carrier_freq
	dim carrier_freq as word = (data_high SHL 8) + data_low
	dim freq_div as word = 12000000 / carrier_freq
	sys.debugprint("carrier_freq: " + str(carrier_freq) + " freq_div: " + str(freq_div) + "\r\n")


	tbt26_get_data= tbt26_get_data + chr(data_low)+chr(data_high) 'carrier

	io.lineset(pin_cs,LOW) 	'Read command sequence
	ssi.value(&h03,8)
	ssi.value(&h08,8)
	ssi.value(&h00,8)
	ssi.value(&h00,8)
	dim data_started as boolean = false
	dim data_data as string = ""
	dim protocol as byte = 0
	dim current_bit as byte = 0
	dim current_bit_value as byte = 0
	dim current_byte as byte = 0
	dim on_duration as word = 0
	dim off_duration as word = 0
	
	' Set multiplier for duration calculations
	dim carrier_divider as word = (data_high SHL 8) + data_low
	tbt26_multiplier = carrier_divider / 12.0
	
	f=5
	while f < data_len
		on_duration=tbt26_get_duration()
		f=f+2
		
		'parse header and data here
		if data_started = false then
			' Check if this is NEC protocol header (9000 ON, 4500 OFF)
			' Allow tolerance of +/- 15% for header detection
			dim p as byte=0
			for p=1 to 3
				if on_duration >= ir_protocols(p).header_mark - 300 and on_duration <= ir_protocols(p).header_mark + 300 then
					protocol = ir_protocols(p).protocol
					data_started = true
					off_duration=tbt26_get_duration() ' skip off duration
					f=f+2
					sys.debugprint("Protocol " + ir_protocols(p).protocol_name + " detected: ON=" + str(on_duration) + " OFF=" + str(off_duration) + "\r\n")
				end if
			next p
			if protocol=0 then
				' Unknown protocol, treat as data start - store raw durations
				protocol = 0
				data_started = true
				' Store this first ON/OFF pair as raw data
				data_data = chr(on_duration AND &hFF) + chr(on_duration SHR 8) + chr(off_duration AND &hFF) + chr(off_duration SHR 8)
				sys.debugprint("Unknown protocol: " + "\r\n")
			end if
			data_data = data_data + chr(protocol)
		else
			' Collecting data bits
			current_bit_value = 0
			if protocol<>0 then 
				off_duration=tbt26_get_duration()
				f=f+2
				dim bit_duration as word = ir_protocols(protocol).logic_1_mark + ir_protocols(protocol).logic_1_space
				dim bit_duration_tolerance as word = bit_duration * 0.15
				if on_duration + off_duration > bit_duration - bit_duration_tolerance and on_duration + off_duration <= bit_duration + bit_duration_tolerance then
					current_bit_value = 1
				end if
			else
				'unknown protocol
			end if
			if protocol <> 0 then
				current_byte = (current_byte SHL 1) + current_bit_value
				current_bit = current_bit + 1
				if current_bit = 8 then
					data_data = data_data + chr(current_byte)
					current_byte = 0
					current_bit = 0
				end if
			else
				data_data = data_data + chr(on_duration AND &hFF) + chr(on_duration SHR 8) + chr(off_duration AND &hFF) + chr(off_duration SHR 8)
			end if
		end if
	wend
	
	' If there are remaining bits (not a full byte), store the partial byte
	if current_bit > 0 and (protocol = IR_PROTOCOL_NEC or protocol = IR_PROTOCOL_JVC) then
		data_data = data_data + chr(current_byte)
		sys.debugprint("Partial byte (" + str(current_bit) + " bits): " + hex(current_byte) + "\r\n")
	end if
	tbt26_get_data = tbt26_get_data + data_data
	io.lineset(pin_cs,HIGH)
end function


sub tbt26_play_back(byref data as string, pin_cs as byte, channel as byte)
	if len(data) = 0 then
		sys.debugprint("command empty")
		exit sub
	end if

	'get carrier
	dim carrier as string=mid(data,3,2)
	dim data_len as word=(asc(mid(data,2,1)) SHL 8) + asc(mid(data,1,1))
	dim data_send_len as word=len(data)
	dim protocol as byte=asc(mid(data,5,1))
	dim f as word=0
	ssi.channel=channel

	dim carrier_divider as word = (asc(mid(carrier,2,1)) SHL 8) + asc(mid(carrier,1,1))
	tbt26_multiplier = carrier_divider / 12.0

	tbt26_start_send(carrier,data_len,pin_cs,channel)


	io.lineset(pin_cs,LOW)	'Write to command memory
	ssi.value(&h02,8)
	ssi.value(&h08,8)
	ssi.value(&h00,8)

	if protocol <> 0 then
		tbt26_write_duration(ir_protocols(protocol).header_mark)
		tbt26_write_duration(ir_protocols(protocol).header_space)
	end if
	f=6
	
	while f <= data_send_len
		dim partial_data as string=mid(data,f,2)
		dim tmp as word = 0
		dim i as byte=0
		dim tmp_data as byte
		if protocol <> 0 then
			partial_data=mid(data,f,1)
			tmp_data = asc(partial_data)
			for i=1 to 8
				tmp = tmp_data SHR (8-i) AND &h01
				if tmp = 1 then
					tbt26_write_duration(ir_protocols(protocol).logic_1_mark)
					tbt26_write_duration(ir_protocols(protocol).logic_1_space)
				else
					tbt26_write_duration(ir_protocols(protocol).logic_0_mark)
					tbt26_write_duration(ir_protocols(protocol).logic_0_space)
				end if
			next i
			f=f+1
		else
			tmp = (asc(mid(partial_data,2,1)) SHL 8) + asc(mid(partial_data,1,1))
			tmp = tmp * tbt26_multiplier
			tbt26_write_duration(tmp)
			f=f+2
		end if
	wend
	io.lineset(pin_cs,HIGH)
	tbt26_transmit(NO,pin_cs,channel)
end sub

sub tbt26_start_send(byref carrier as string, length as word, pin_cs as byte, channel as byte)
	dim data_low,data_high as byte
	bcount=0
	
	if ir_init_flag<>IR_INIT_SIGNATURE then
		sys.debugprint("IR tibbit not initialized\r\n")
		exit sub
		' tbt26_init()
	end if
	
	ssi.channel=channel
	
	'sys.debugprint("sendlen" + str(length)+"\r\n")
	data_low=0
	
	'wait until the previous transmission (if any) is finished with timeout of 3 seconds
	dim timeout as dword=sys.timercountms+3000
	while data_low<>3 AND sys.timercountms<timeout
		io.lineset(pin_cs,LOW) 	
		ssi.value(&h03,8)
		ssi.value(&h00,8)
		ssi.value(&h01,8)
		ssi.value(&h00,8)
		data_low = ssi.value(&h00,8) 'status in data_low
		io.lineset(pin_cs,HIGH)
		sys.debugprint("W")
	wend

	if length < 4 then
		exit sub
	end if
	data_low=length AND &hff
	data_high=length SHR 8

	io.lineset(pin_cs,LOW)		'Write Length 
	ssi.value(&h02,8)
	ssi.value(&h00,8)
	ssi.value(&h02,8)
	ssi.value(data_low,8)
	ssi.value(data_high,8)
	io.lineset(pin_cs,HIGH)
	
	data_low=asc(mid(carrier,1,1))
	data_high=asc(mid(carrier,2,1))
	
	io.lineset(pin_cs,LOW)		'Write Carrier 
	ssi.value(&h02,8)
	ssi.value(&h00,8)
	ssi.value(&h06,8)
	ssi.value(data_low,8)
	ssi.value(data_high,8)
	io.lineset(pin_cs,HIGH)
end sub

#if IR_DEBUG_PRINT=1
sub ir_debug_print(data as string)
	sys.debugprint(IR_STAMP+data+IR_CR_LF)
end sub
#endif
