include "global.tbh"

function math_pow(base as integer, exp as integer) as real
	dim p as real = 1.0
	dim i as integer
	dim xx as real = base
	if exp < 0 then
		exp = -1 * exp
		xx = 1 / xx
	end if
	for i=1 to exp
		p = p * xx
	next i
	math_pow = p
end function

function abs(Value as real) as real
    abs = Value * sgn(Value)
end function

function sgn(Value as real) as real
    if Value < 0 then sgn = -1 else sgn = 1
end function


function math_hex_to_float(byref num as string(8)) as real
	dim tmp as dword = lval("&h" + num)
	dim sign as byte = (tmp SHR 31)
	dim exponent as integer = ((tmp SHR 23) AND &hFF)
	dim mantissa as dword = (tmp AND &h7FFFFF)  ' Extract 23-bit mantissa
	
	' Handle special cases
	if exponent = 0 then
		if mantissa = 0 then
			math_hex_to_float = 0.0  ' Zero
		else
			' Denormalized number
			math_hex_to_float = (mantissa / math_pow(2, 23)) * math_pow(2, -126)
		end if
	else if exponent = 255 then
		if mantissa = 0 then
			' Infinity - return a large number since we can't represent true infinity
			math_hex_to_float = 3.4028235e38
		else
			' NaN - return 0 or handle as needed
			math_hex_to_float = 0.0
		end if
	else
		' Normalized number - add implicit leading 1
		dim full_mantissa as real = 1.0 + (mantissa / math_pow(2, 23))
		math_hex_to_float = full_mantissa * math_pow(2, exponent - 127)
	end if
	
	if sign = 1 then
		math_hex_to_float = -math_hex_to_float
	end if
end function

#IF REQUIRES_BASE64
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
dim base64_chars as byte(64) = {
		&h41, &h42, &h43, &h44, &h45, &h46, &h47, &h48, &h49, &h4A, &h4B, &h4C, &h4D, &h4E, &h4F,
  &h50, &h51, &h52, &h53, &h54, &h55, &h56, &h57, &h58, &h59, &h5A,
		&h61, &h62, &h63, &h64, &h65, &h66, &h67, &h68, &h69, &h6A, &h6B, &h6C, &h6D, &h6E, &h6F,
  &h70, &h71, &h72, &h73, &h74, &h75, &h76, &h77, &h78, &h79, &h7A,
		&h30, &h31, &h32, &h33, &h34, &h35, &h36, &h37, &h38, &h39, &h2B, &h2F,
}

dim base64_inv as byte(80) = { 
	62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58,
	59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5,
	6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
	21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
	29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
	43, 44, 45, 46, 47, 48, 49, 50, 51 
}

sub base64_encode(byref input_str as string, input_len as byte, byref result as string)
	dim out_len as byte
	dim in as byte(255) = input_str
	dim out as byte(255)
	dim i as byte = 0
	dim j as byte = 0
	dim v as dword = 0
	dim index as byte
	if input_len > 254 then
		exit sub
	end if
	out_len = input_len
	if input_len MOD 3 <> 0 then
		out_len = out_len + 3 - (input_len MOD 3)
	end if
	out_len = out_len / 3
	out_len = out_len * 4	
	
	
	for i=0 to input_len step 3
		v = in(i)
		if i + 1 < input_len then
			v = (v SHL 8) OR in(i + 1)
		else
			v = v SHL 8
		end if
		
		if i + 2 < input_len then
			v = (v SHL 8) OR in(i + 2)
		else
			v = v SHL 8
		end if
		
		out(j) = base64_chars((v SHR 18) AND &h3F)
		out(j + 1) = base64_chars((v SHR 12) AND &h3F)
		if i + 1 < input_len then
			out(j + 2) = base64_chars((v SHR 6) AND &h3F)
		else
			out(j + 2) = &h3D '=
		end if
		
		if i + 2 < input_len then
			out(j + 3) = base64_chars(v AND &h3F)
		else
			out(j + 3) = &h3D '=
		end if

		j = j + 4
	next i

	result = out
	result = mid(result,0,out_len)
	
end sub

sub base64_decode(byref input as string, byref result as string)
	
	dim str_len as byte = 0
	dim i as byte
	dim j as byte
	dim v as dword
	dim out as byte(255)
	dim in as byte(255)
	in = input
	for i = len(input) to 255 - 1
		in(i) = 0
	next i
	
	for i = 0 to 255 - 1
		if in(i) <> 0 then
			str_len = str_len + 1
		end if
		out(i) = 0
	next i
	
	dim out_len as byte = str_len / 4 * 3
	for i=str_len-1 to 0 step -1
		if in(i) = &h3D then
			out_len = out_len - 1
		else
			exit for
		end if
	next i
	
	j = 0
	for i=0 to str_len-1 step 4
	
		v = base64_inv(in(i)-43)
		v = (v SHL 6) OR base64_inv(in(i+1)-43)
		
		if in(i+2)=&h3D then
			v = v SHL 6
		else
			v = (v SHL 6) OR base64_inv(in(i + 2) - 43)
		end if
		if in(i+3)=&h3D then
			v = v SHL 6
		else
			v = (v SHL 6) OR base64_inv(in(i + 3) - 43)
		end if
		
		out(j) = (v SHR 16) AND &hFF
		
		if in(i+2) <> &h3D then
			out(j+1) = (v SHR 8) AND &hFF
		end if
		
		if in(i+3) <> &h3D then
			out(j+2) = v AND &hFF
		end if

	
		j = j + 3
	next i

	result = out
	result = mid(result,0,out_len)

end sub
#ENDIF

sub date_set_datetime(byref dt_string as string)
	
	dim daycounts, mincounts as word
	dim curr_daycounts, curr_mincounts as word
	dim syear,smonth,sdate,shour,smin,ssec as string(4)
	dim b as byte
	
	syear=mid(dt_string,15,2)
	smonth=mid(dt_string,9,3)
	sdate=mid(dt_string,6,2)
	shour=mid(dt_string,18,2)
	smin=mid(dt_string,21,2)
	ssec=mid(dt_string,24,2)
	
	select case smonth
	case "Jan": smonth="01"
	case "Feb": smonth="02"
	case "Mar": smonth="03"
	case "Apr": smonth="04"
	case "May": smonth="05"
	case "Jun": smonth="06"
	case "Jul": smonth="07"
	case "Aug": smonth="08"
	case "Sep": smonth="09"
	case "Oct": smonth="10"
	case "Nov": smonth="11"
	case "Dec": smonth="12"
	case else:
	end select
	daycounts=daycount(val(syear),val(smonth),val(sdate))
	mincounts=mincount(val(shour),val(smin))
#if PLATFORM_ID <> EM500W AND PLATFORM_ID <> EM510W
	rtc.getdata(curr_daycounts,curr_mincounts, b)
	if curr_daycounts<>daycounts or curr_mincounts<>mincounts then
		b=val(ssec) 	
		rtc.setdata(daycounts,mincounts,b)
	end if
#endif		
end sub

function string_to_float(byref s as string) as float
	' IEEE 754 string to float conversion algorithm
	if len(s)=0 then
		string_to_float=0.0
		exit function
	end if
	
	' Handle sign
	dim is_negative as byte = 0
	dim start_pos as byte = 1
	if mid(s, 1, 1) = "-" then
		is_negative = 1
		start_pos = 2
	end if
	if mid(s, 1, 1) = "+" then
		start_pos = 2
	end if
	
	' Handle special cases
	dim number_part as string(FLOAT_MAX_STRING_LENGTH) = mid(s, start_pos, len(s) - start_pos + 1)
	if number_part = "0" or number_part = "0.0" then
		string_to_float = 0.0
		exit function
	end if
	
	' Find decimal point
	dim decimal_pos as byte = instr(1, number_part, ".", 1)
	dim integer_part as string(FLOAT_MAX_STRING_LENGTH)
	dim fractional_part as string(FLOAT_MAX_STRING_LENGTH)
	
	if decimal_pos = 0 then
		' No decimal point - integer only
		integer_part = number_part
		fractional_part = ""
	else
		integer_part = mid(number_part, 1, decimal_pos - 1)
		fractional_part = mid(number_part, decimal_pos + 1, len(number_part) - decimal_pos)
	end if
	
	' Convert integer part
	dim result as real = 0.0
	if len(integer_part) > 0 and integer_part <> "0" then
		dim int_value as long = lval(integer_part)
		result = int_value
	end if
	
	' Convert fractional part using more precise method
	if len(fractional_part) > 0 then
		dim frac_value as real = 0.0
		dim power_of_ten as real = 0.1
		dim i as byte
		
		for i = 1 to len(fractional_part)
			dim digit_char as string(1) = mid(fractional_part, i, 1)
			dim digit_val as byte = asc(digit_char) - asc("0")
			
			' Validate digit
			if digit_val >= 0 and digit_val <= 9 then
				frac_value = frac_value + (digit_val * power_of_ten)
				power_of_ten = power_of_ten * 0.1
			end if
		next i
		
		result = result + frac_value
	end if
	
	' Apply sign
	if is_negative = 1 then
		result = -result
	end if
	
	string_to_float = result
' #IF SYS_VER=2000
' 	string_to_float=strtof(s)
' #ENDIF
end function

function ftofixed(r as real, decimals as byte) as string
	' ftofixed = fstr(r)
	' dim pos as byte = instr(1,ftofixed, ".", 1)
	' if pos = 0  then
	' 	exit function
	' else 
	' 	if instr(1,ftofixed,"-",1) <> 0 then
	' 		pos=pos-1
	' 	end if
	' 	ftofixed=ftostr(r,FTOSTR_MODE_PLAIN,pos+decimals-1)
	' end if
	
	'use the shortest decimal representation
	ftofixed = float_to_shortest_decimal_precise(r)
end function

sub time_delay_ms(delay_ms as word)
	dim target as dword=sys.timercountms + delay_ms
	while sys.timercountms < target
	wend
end sub

function hex_mac(byref mac as string) as string
	dim i as integer = 0
	dim startpos as integer = 1
	dim endpos as integer = 0
	dim num as word = ""
	
	for i = 0 to 5
		endpos = instr(startpos,mac,".",0)
		num = val(  mid(mac,startpos,  endpos-startpos) )
		if num<>0 then
			if num < 16 then
				hex_mac = hex_mac + "0" + right(hex(num),1) + ":"
			else
				hex_mac = hex_mac + right(hex(num),2) + ":"
			end if
		else
			hex_mac = hex_mac + "00" + ":"
		end if
		startpos=endpos+1
	next i

	hex_mac = left(hex_mac,len(hex_mac)-1)

end function


function json_get_value(byref key as string, byref data as string) as string
    json_get_value=""
    dim start_pos as byte=0
    dim end_pos as byte=0
    dim current_key as string=""
    start_pos=instr(1,data,"{",1)
    while start_pos<>0
        'get current key
        start_pos=instr(start_pos,data,"\x22",1)
        if start_pos<>0 then
            end_pos=instr(start_pos+1,data,"\x22",1)
            current_key=mid(data,start_pos+1,end_pos-start_pos-1)

            'get value
            start_pos=instr(end_pos,data,":",1)
            if start_pos<>0 then
                end_pos=instr(start_pos,data,",",1)
                if end_pos=0 then
					'get last occurrence of }
					dim last_pos as byte=0
					while last_pos<len(data)
						last_pos=instr(last_pos+1,data,"}",1)
						if last_pos=0 then
							exit while
						end if
						last_pos=last_pos+1
					wend
					if last_pos<>0 then
                    	end_pos=last_pos-1
					end if
                end if
                
            end if
            if current_key=key then
                dim is_string as boolean=instr(start_pos,data,"\x22",1)=start_pos+1
                if is_string then
                    'is string so look for closing quote
                    dim tmp_end as byte=start_pos+1
                    while tmp_end<len(data)
                        tmp_end=instr(tmp_end+1,data,"\x22",1)
                        if tmp_end=0 then
                            exit while
                        end if
                        if mid(data,tmp_end-1,1)<>"\x5c" then
                            end_pos=tmp_end+1
                            exit while
                        end if
                    wend
                end if
                json_get_value=mid(data,start_pos+1,end_pos-start_pos-1)
                if is_string then
					json_get_value=unescape_string(json_get_value)
                end if
                if instr(1,json_get_value,"\x22",1)=1 then
                    json_get_value=mid(json_get_value,2,len(json_get_value)-2)
                end if
                exit function
            end if
            start_pos=end_pos+1

        end if
    wend
end function

function escape_string(data as string) as string
    dim x, tmp_instr as byte
    dim k as byte=1
	dim i as byte=0
    escape_string=""
	
	dim special_characters as string(10)="\x22\r\n\x5c\t"
	dim escaped_chars as string(10)="\x22rn\x5ct"
    while k < len(data) + 1
		for i=0 to len(special_characters)-1
			dim escape_char as string(1)=mid(special_characters,i+1,1)
			dim escaped_char as string(1)=mid(escaped_chars,i+1,1)
			dim current_char as string(1)=mid(data,k,1)
			if escape_char = current_char then
				x=k
				dim tmp1 as string=mid(data,1,x-1)
				dim tmp2 as string=mid(data,x + 1,len(data)-x)
				data=tmp1+"\x5c"+escaped_char+tmp2
				k = k + 1
			end if
		next i
		k=k+1
    wend
	escape_string=data
end function

function unescape_string(data as string) as string
    dim x, tmp_instr, offset as byte
    dim k as byte=1
    dim unescaped_char as string(1)=""
    unescape_string=data

	while k < len(unescape_string) - 1
		dim current_char as string(1)=mid(unescape_string,k,1)
		'\
		if current_char="\x5c" then
			current_char=mid(unescape_string,k + 1,1)
			select case current_char
			case "r":
				unescaped_char="\r"
			case "n":
				unescaped_char="\n"
			case "t":
				unescaped_char="\t"
			case "\x5c":
				unescaped_char="\x5c"
			case "\x22":
				unescaped_char="\x22"
			case else:
				unescaped_char=current_char
			end select
			dim tmp1 as string=mid(unescape_string,1,k-1)
			dim tmp2 as string=mid(unescape_string,k + 2,255)
			unescape_string=tmp1+unescaped_char+tmp2
		end if
		
		k=k+1
    wend
end function

function str_to_hex(hash as string) as string
	dim i as byte
	dim j as byte
    dim result as byte(255)
	str_to_hex=""
	for i=0 to len(hash)-1
		dim part as string(2)=mid(hex(asc(mid(hash,i+1,1))),3,2)
		if len(part)=1 then
			part="0" + part
		end if
		str_to_hex=str_to_hex+part
	next i
    result=str_to_hex
	j=len(str_to_hex)
	str_to_hex=""
    for i=0 to j-1
        if result(i)<97 AND result(i)>=65 then
            result(i)=result(i)+32
        end if
		str_to_hex=str_to_hex+chr(result(i))
    next i
end function


' Helper function to remove trailing zeros and unnecessary decimal point
function trim_trailing_zeros(s as string(FLOAT_MAX_STRING_LENGTH)) as string(FLOAT_MAX_STRING_LENGTH)
	dim result as string = s
	
	' Only trim if there's a decimal point
	if instr(1, result, ".", 1) > 0 then
		' Remove trailing zeros
		while len(result) > 1 and right(result, 1) = "0"
			result = left(result, len(result) - 1)
		wend
		
		' Remove trailing decimal point if no fractional part remains
		if len(result) > 1 and right(result, 1) = "." then
			result = left(result, len(result) - 1)
		end if
	end if
	
	trim_trailing_zeros = result
end function

' Enhanced version that finds the true shortest decimal representation
function float_to_shortest_decimal_precise(f as real) as string(FLOAT_MAX_STRING_LENGTH)
	' Handle special cases
	if f = 0.0 then
		float_to_shortest_decimal_precise = "0"
		exit function
	end if
	
	dim temp_str as string(FLOAT_MAX_STRING_LENGTH) = fstr(f)
	if instr(1, temp_str, "inf", 1) > 0 then
		if f < 0 then
			float_to_shortest_decimal_precise = "-Infinity"
		else
			float_to_shortest_decimal_precise = "Infinity"
		end if
		exit function
	end if
	
	if instr(1, temp_str, "nan", 1) > 0 then
		float_to_shortest_decimal_precise = "NaN"
		exit function
	end if
	
	' Handle negative
	dim is_negative as boolean = f < 0
	if is_negative then
		f = -f
	end if
	
	' Implementation of shortest decimal representation algorithm
	' This finds the shortest decimal that rounds to the same IEEE 754 value
	dim result as string(FLOAT_MAX_STRING_LENGTH) = find_shortest_decimal(f)
	
	if is_negative then
		float_to_shortest_decimal_precise = "-" + result
	else
		float_to_shortest_decimal_precise = result
	end if
end function

' Core algorithm to find shortest decimal representation
function find_shortest_decimal(f as real) as string(FLOAT_MAX_STRING_LENGTH)
	' Special case for small integers
	dim int_f as long = f
	if int_f = f and f < 1000000 then
		find_shortest_decimal = lstri(int_f)
		exit function
	end if
	
	' For IEEE 754 binary32, we need to find the shortest decimal
	' that when parsed rounds to the same binary value
	
	' Start with a reasonable precision and work our way down
	dim best_candidate as string(FLOAT_MAX_STRING_LENGTH) = ""
	dim best_length as byte = 255
	
	' Try different decimal places from high to low precision
	dim decimal_places as byte
	for decimal_places = 15 to 1 step -1
		dim candidate as string(FLOAT_MAX_STRING_LENGTH) = ftostr(f, FTOSTR_MODE_PLAIN, decimal_places)
		candidate = trim_trailing_zeros(candidate)
		
		' Check if this candidate, when parsed, gives the same binary value
		dim parsed_back as real = string_to_float(candidate)
		
		' Use a more precise comparison - check if they're the same IEEE 754 value
		if are_same_ieee754_value(f, parsed_back) then
			if len(candidate) < best_length then
				best_candidate = candidate
				best_length = len(candidate)
			end if
		end if
	next decimal_places
	
	' If we didn't find a good candidate, try a different approach
	if best_candidate = "" then
		best_candidate = fallback_shortest_decimal(f)
	end if
	
	find_shortest_decimal = best_candidate
end function

' Check if two floats represent the same IEEE 754 binary value
function are_same_ieee754_value(a as real, b as real) as boolean
	' For practical purposes in this environment, check if they're very close
	' This is a simplified version - ideally we'd compare the actual bit patterns
	dim diff as real = abs(a - b)
	dim epsilon as real = abs(a) * 0.0000001  ' Relative epsilon
	if epsilon < 0.0000000001 then
		epsilon = 0.0000000001  ' Minimum absolute epsilon
	end if
	
	are_same_ieee754_value = (diff <= epsilon)
end function

' Simplified Dragon4-inspired algorithm for shortest decimal representation
function fallback_shortest_decimal(f as real) as string
	' This implements a simplified version of the Dragon4 algorithm
	' The idea is to find the shortest decimal string that, when parsed,
	' rounds to the same IEEE 754 binary value
	
	' Start with high precision and work down to find shortest accurate representation
	dim shortest_str as string(FLOAT_MAX_STRING_LENGTH) = ""
	dim shortest_len as byte = 255
	
	' Try different approaches: both rounding up and down at each precision level
	dim precision as byte
	for precision = 1 to 15
		dim base_str as string(FLOAT_MAX_STRING_LENGTH) = ftostr(f, FTOSTR_MODE_PLAIN, precision)
		base_str = trim_trailing_zeros(base_str)
		
		' Test if this representation round-trips correctly
		if test_round_trip_accuracy(f, base_str) then
			if len(base_str) < shortest_len then
				shortest_str = base_str
				shortest_len = len(base_str)
			end if
		end if
		
		' Also try truncated versions (rounding down)
		if precision > 1 then
			dim truncated_str as string(FLOAT_MAX_STRING_LENGTH) = truncate_last_digit(base_str)
			if len(truncated_str) > 0 then
				if test_round_trip_accuracy(f, truncated_str) then
					if len(truncated_str) < shortest_len then
						shortest_str = truncated_str
						shortest_len = len(truncated_str)
					end if
				end if
			end if
		end if
		
		' Try rounding up the last digit
		dim rounded_up_str as string(FLOAT_MAX_STRING_LENGTH) = round_up_last_digit(base_str)
		if rounded_up_str <> base_str then
			if test_round_trip_accuracy(f, rounded_up_str) then
				if len(rounded_up_str) < shortest_len then
					shortest_str = rounded_up_str
					shortest_len = len(rounded_up_str)
				end if
			end if
		end if
	next precision
	
	if shortest_str = "" then
		' Fallback to reasonable precision
		shortest_str = trim_trailing_zeros(ftostr(f, FTOSTR_MODE_PLAIN, 6))
	end if
	
	fallback_shortest_decimal = shortest_str
end function

' Test if a decimal string round-trips to the same IEEE 754 value
function test_round_trip_accuracy(original as real, decimal_str as string(FLOAT_MAX_STRING_LENGTH)) as boolean
	dim parsed_back as real = string_to_float(decimal_str)
	test_round_trip_accuracy = are_same_ieee754_value(original, parsed_back)
end function

' Truncate the last digit of a decimal string
function truncate_last_digit(s as string(FLOAT_MAX_STRING_LENGTH)) as string(FLOAT_MAX_STRING_LENGTH)
	if len(s) <= 1 then
		truncate_last_digit = ""
		exit function
	end if
	
	dim dot_pos as byte = instr(1, s, ".", 1)
	if dot_pos = 0 then
		' No decimal point, truncate last digit of integer
		truncate_last_digit = left(s, len(s) - 1)
	else
		if dot_pos = len(s) - 1 then
			' Decimal point is at end, remove both decimal point and last digit
			truncate_last_digit = left(s, len(s) - 2)
		else
			' Remove last digit after decimal point
			truncate_last_digit = left(s, len(s) - 1)
		end if
	end if
	
	' Clean up result
	truncate_last_digit = trim_trailing_zeros(truncate_last_digit)
end function

' Round up the last digit of a decimal string
function round_up_last_digit(s as string(FLOAT_MAX_STRING_LENGTH)) as string(FLOAT_MAX_STRING_LENGTH)
	if len(s) = 0 then
		round_up_last_digit = s
		exit function
	end if
	
	dim dot_pos as byte = instr(1, s, ".", 1)
	dim last_digit_pos as byte = len(s)
	dim last_char as string(1) = right(s, 1)
	
	' Check if last character is a digit
	if asc(last_char) >= asc("0") and asc(last_char) <= asc("8") then
		' Can round up
		dim new_digit as string(1) = chr(asc(last_char) + 1)
		round_up_last_digit = left(s, len(s) - 1) + new_digit
	else if last_char = "9" then
		' Need to carry over - this is complex, so we'll use a simple approach
		' Convert to number, add small increment, and format again
		dim val as real = string_to_float(s)
		dim increment as real = 0.1
		
		' Calculate appropriate increment based on position
		if dot_pos > 0 then
			dim digits_after_decimal as byte = len(s) - dot_pos
			if digits_after_decimal > 0 then
				increment = math_pow(10, -digits_after_decimal)
			end if
		else
			increment = 1
		end if
		
		dim new_val as real = val + increment
		round_up_last_digit = trim_trailing_zeros(ftostr(new_val, FTOSTR_MODE_PLAIN, len(s)))
	else
		' Not a digit, return as-is
		round_up_last_digit = s
	end if
end function